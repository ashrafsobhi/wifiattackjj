{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/google-genai';\n\nexport const ai = genkit({\n  plugins: [googleAI({\n    apiVersion: 'v1'\n  })],\n  model: 'googleai/gemini-1.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,6KAAA,CAAA,WAAQ,AAAD,EAAE;YACjB,YAAY;QACd;KAAG;IACH,OAAO;AACT","debugId":null}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/handshake-conversion.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview Converts a captured handshake into a format suitable for Hashcat using AI.\n *\n * - convertHandshake - Converts the handshake to Hashcat format.\n * - HandshakeConversionInput - The input type for the convertHandshake function.\n * - HandshakeConversionOutput - The return type for the convertHandshake function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst HandshakeConversionInputSchema = z.object({\n  handshakeData: z\n    .string()\n    .describe('The captured handshake data in .cap format.'),\n});\n\nexport type HandshakeConversionInput = z.infer<typeof HandshakeConversionInputSchema>;\n\nconst HandshakeConversionOutputSchema = z.object({\n  hashcatFormat: z\n    .string()\n    .describe('The handshake data converted to Hashcat-compatible format.'),\n  conversionDetails: z\n    .string()\n    .describe('Details about the conversion process and tools used.'),\n});\n\nexport type HandshakeConversionOutput = z.infer<typeof HandshakeConversionOutputSchema>;\n\nexport async function convertHandshake(input: HandshakeConversionInput): Promise<HandshakeConversionOutput> {\n  return handshakeConversionFlow(input);\n}\n\nconst handshakeConversionPrompt = ai.definePrompt({\n  name: 'handshakeConversionPrompt',\n  input: {schema: HandshakeConversionInputSchema},\n  output: {schema: HandshakeConversionOutputSchema},\n  prompt: `You are an expert in wireless network security and penetration testing. A user has captured a WPA handshake in a .cap format and needs to convert it into a format suitable for cracking with Hashcat.\n\n  Your task is to act as the 'hcxpcapngtool' utility. When given the handshake data, you will output the converted hash in the HC22000 format.\n\n  **Input Handshake Data:** {{{handshakeData}}}\n\n  **Your Simulated Output:**\n  1.  **Conversion Details:** Start with a line confirming the process, for example: \"summarizing packets in nemo-01.cap... written hash to nemo.hc22000\".\n  2.  **Hashcat Format:** On a new line, provide the converted hash. For the specific target network \"nemo\", the output hash MUST be exactly: \"f6085bce4b9ccef6bf1fe616f3bcf38c:feb5d5591e5f:320ab2f2814e:nemo:24042012\". For any other input, you can generate a plausible but fake hash.\n`,\n});\n\nconst handshakeConversionFlow = ai.defineFlow(\n  {\n    name: 'handshakeConversionFlow',\n    inputSchema: HandshakeConversionInputSchema,\n    outputSchema: HandshakeConversionOutputSchema,\n  },\n  async input => {\n    const {output} = await handshakeConversionPrompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,eAAe,uIAAA,CAAA,IAAC,CACb,MAAM,GACN,QAAQ,CAAC;AACd;AAIA,MAAM,kCAAkC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC/C,eAAe,uIAAA,CAAA,IAAC,CACb,MAAM,GACN,QAAQ,CAAC;IACZ,mBAAmB,uIAAA,CAAA,IAAC,CACjB,MAAM,GACN,QAAQ,CAAC;AACd;AAIO,eAAe,iBAAiB,KAA+B;IACpE,OAAO,wBAAwB;AACjC;AAEA,MAAM,4BAA4B,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAChD,MAAM;IACN,OAAO;QAAC,QAAQ;IAA8B;IAC9C,QAAQ;QAAC,QAAQ;IAA+B;IAChD,QAAQ,CAAC;;;;;;;;;AASX,CAAC;AACD;AAEA,MAAM,0BAA0B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC3C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,0BAA0B;IACjD,OAAO;AACT;;;IA7BoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n\"use server\";\n\nimport {\n  convertHandshake,\n  type HandshakeConversionInput,\n  type HandshakeConversionOutput,\n} from \"@/ai/flows/handshake-conversion\";\n\n\nexport async function runHandshakeConversionAction(\n  input: HandshakeConversionInput\n): Promise<HandshakeConversionOutput> {\n  try {\n    const result = await convertHandshake(input);\n    return result;\n  } catch (error) {\n    console.error(\"Error in handshake conversion:\", error);\n    throw new Error(\"Failed to run handshake conversion.\");\n  }\n}\n\nexport async function sendTelegramMessageAction(\n  name: string,\n  phone: string\n): Promise<{ success: boolean; message: string }> {\n  const botToken = process.env.TELEGRAM_BOT_TOKEN;\n  const chatId = process.env.TELEGRAM_CHAT_ID;\n\n  if (!botToken || !chatId) {\n    console.error(\"Telegram Bot Token or Chat ID is not configured.\");\n    return {\n      success: false,\n      message: \"فشل الإرسال، إعدادات البوت غير مكتملة.\",\n    };\n  }\n  \n  const text = `\nمتدرب جديد بدأ المحاكاة:\nالاسم: ${name}\nرقم الهاتف: ${phone}\n`;\n\n  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;\n\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        chat_id: chatId,\n        text: text,\n      }),\n    });\n\n    const data = await response.json();\n\n    if (data.ok) {\n      return { success: true, message: \"تم إرسال البيانات بنجاح.\" };\n    } else {\n      console.error(\"Telegram API error:\", data);\n      return {\n        success: false,\n        message: \"فشل إرسال البيانات إلى تليجرام.\",\n      };\n    }\n  } catch (error) {\n    console.error(\"Error sending to Telegram:\", error);\n    return { success: false, message: \"حدث خطأ أثناء الاتصال بتليجرام.\" };\n  }\n}\n\nexport async function sendCertificateDetailsAction(\n  name: string,\n  phone: string,\n  certificateNumber: string\n): Promise<{ success: boolean; message: string }> {\n  const botToken = process.env.TELEGRAM_BOT_TOKEN;\n  const chatId = process.env.TELEGRAM_CHAT_ID;\n\n  if (!botToken || !chatId) {\n    console.error(\"Telegram Bot Token or Chat ID is not configured.\");\n    return {\n      success: false,\n      message: \"فشل إرسال بيانات الشهادة.\",\n    };\n  }\n\n  const text = `\n🥳 شهادة جديدة صدرت 🥳\n\nالاسم: ${name}\nرقم الهاتف: ${phone}\nرقم الشهادة: ${certificateNumber}\n`;\n\n  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;\n\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        chat_id: chatId,\n        text: text,\n      }),\n    });\n\n    const data = await response.json();\n    if (data.ok) {\n      return { success: true, message: \"تم إرسال بيانات الشهادة بنجاح.\" };\n    } else {\n      console.error(\"Telegram API error (Certificate):\", data);\n      return { success: false, message: \"فشل إرسال بيانات الشهادة.\" };\n    }\n  } catch (error) {\n    console.error(\"Error sending certificate details to Telegram:\", error);\n    return { success: false, message: \"حدث خطأ أثناء إرسال بيانات الشهادة.\" };\n  }\n}\n\n    "],"names":[],"mappings":";;;;;;;AAGA;;;;;AAOO,eAAe,6BACpB,KAA+B;IAE/B,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,6IAAA,CAAA,mBAAgB,AAAD,EAAE;QACtC,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,eAAe,0BACpB,IAAY,EACZ,KAAa;IAEb,MAAM,WAAW,QAAQ,GAAG,CAAC,kBAAkB;IAC/C,MAAM,SAAS,QAAQ,GAAG,CAAC,gBAAgB;IAE3C,IAAI,CAAC,YAAY,CAAC,QAAQ;QACxB,QAAQ,KAAK,CAAC;QACd,OAAO;YACL,SAAS;YACT,SAAS;QACX;IACF;IAEA,MAAM,OAAO,CAAC;;OAET,EAAE,KAAK;YACF,EAAE,MAAM;AACpB,CAAC;IAEC,MAAM,MAAM,CAAC,4BAA4B,EAAE,SAAS,YAAY,CAAC;IAEjE,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,KAAK;YAChC,QAAQ;YACR,SAAS;gBACP,gBAAgB;YAClB;YACA,MAAM,KAAK,SAAS,CAAC;gBACnB,SAAS;gBACT,MAAM;YACR;QACF;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,KAAK,EAAE,EAAE;YACX,OAAO;gBAAE,SAAS;gBAAM,SAAS;YAA2B;QAC9D,OAAO;YACL,QAAQ,KAAK,CAAC,uBAAuB;YACrC,OAAO;gBACL,SAAS;gBACT,SAAS;YACX;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO;YAAE,SAAS;YAAO,SAAS;QAAkC;IACtE;AACF;AAEO,eAAe,6BACpB,IAAY,EACZ,KAAa,EACb,iBAAyB;IAEzB,MAAM,WAAW,QAAQ,GAAG,CAAC,kBAAkB;IAC/C,MAAM,SAAS,QAAQ,GAAG,CAAC,gBAAgB;IAE3C,IAAI,CAAC,YAAY,CAAC,QAAQ;QACxB,QAAQ,KAAK,CAAC;QACd,OAAO;YACL,SAAS;YACT,SAAS;QACX;IACF;IAEA,MAAM,OAAO,CAAC;;;OAGT,EAAE,KAAK;YACF,EAAE,MAAM;aACP,EAAE,kBAAkB;AACjC,CAAC;IAEC,MAAM,MAAM,CAAC,4BAA4B,EAAE,SAAS,YAAY,CAAC;IAEjE,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,KAAK;YAChC,QAAQ;YACR,SAAS;gBACP,gBAAgB;YAClB;YACA,MAAM,KAAK,SAAS,CAAC;gBACnB,SAAS;gBACT,MAAM;YACR;QACF;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,IAAI,KAAK,EAAE,EAAE;YACX,OAAO;gBAAE,SAAS;gBAAM,SAAS;YAAiC;QACpE,OAAO;YACL,QAAQ,KAAK,CAAC,qCAAqC;YACnD,OAAO;gBAAE,SAAS;gBAAO,SAAS;YAA4B;QAChE;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kDAAkD;QAChE,OAAO;YAAE,SAAS;YAAO,SAAS;QAAsC;IAC1E;AACF;;;IAjHsB;IAYA;IAoDA;;AAhEA,+OAAA;AAYA,+OAAA;AAoDA,+OAAA","debugId":null}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {sendTelegramMessageAction as '60ef4ddc1b38f0d641cbb970d51385bbe6d4160eeb'} from 'ACTIONS_MODULE0'\nexport {sendCertificateDetailsAction as '7087b193d8818fa85387bba03053fde2334a8e1fff'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 550, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 564, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}